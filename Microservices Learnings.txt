Microservice Project

Product Service: Create and View Products, acts as Product Catalog.

Order Service: Can Order Products.

Inventory Service: Can check if product is in stock or not.

Notification Service: Can send notifications, after order is placed.

** Order Service, Inventory Service, Notification Service are going to interact with each other.

** Will have the Synchronous and Asynchronous Communication.


For Asynchronous Communication we are going to use of 2 softwares Message Queues like Kafka and Rabbit MQ's

We will use the KeyCloak as Authorization server

we will use Vault to store the secrets.

Zipkin for distributed tracing

For logging we will use Elasticsearch, logstash, Kibana.

Create the Product Service From Spring Initializer and add dependencies like spring cloud, spring web, eureka client, Lombok, mongodb

setup the mongo db in Product service and configure it in application.properties (uri, username, password, 
uri = mongodb://localhost:27817/product-service



Create a model pkg and create a Product Class there. make it Document
@Document(value = "Product")
Add All Lombok annotations

** Learn about @Builder

Product has @ID id, name, description, price

Create a repository package and create an interface as ProductRepository extends MongoRepository<Product,String>

Create a Controller package and create ProductController, annotate it with RestController, RequestMapping("/api/product")

create Api's for create, get, getAll (use @ResponseStatus for returning response)

create a ProductRequest DTO (have all fields except id because we will autogenerate it)

create service package and ProductService class to create methods related to them.

use builder method to build the Product Object

use slf4j for logging

create ProductResponse DTO for response, return everything, even id because we can use it in Order or Product identification,


Write the tests for the Product service in test package-> ProductServiceApplicationTests class
we are going the write the Integration test.

first install a library called TestContainers -> Java Library that supports the unit tests.


Learn about selenium.

add the maven dependency of TestContainers

BOM -> Bill of Materials
if we want to put the same version for all the components like for Kafka, MongoDB then use BOM dependency
take the mongodb maven dependency from TestContainers documentation
and remove the version because we have defined it in BOM dependency, otherwise it may cause issue
as we are using the JUnit 5 for testing so we need that dependency too for TestContainers and put the junit-jupiter dependency and remove the version

Let's start writing the integration test
add @TestContainers Annotation on top of the class and define the MongoDb Container inside the Test class and create its object 

MongoDbContainer is deprecated because we cannot use the NoArgsConstructor anymore, we have to manually specify the version of the MongoDbContainer, so for that we need to provide the docker image name, we are providing as "mongo:4.4.2" so this is the mongo version we want to use for test. add @Container at top of the MongoDbContainer instance and make it static .

create the static setProperties method and add annotation @DynamicPropertySource with DynamicPropertyRegistry parameter and call the add method with 2 parameters, one is uri "spring.data.mongodb.uri", mongodbcontainer::getReplicaSetUrl)
 


so at the time of starting the integration test, first test will start the mongodbcontainer with specified docker image and then it will get the replicaSetUrl and add to mongodb.uri property at time of creating the test,
we are taking the image for mongodb for testing because we dont want to use our local db




Now we are creating the test case for createProduct api in which we are expecting the ResponseStatus.Created as Response
@Test
void shouldCreateProduct() throws JsonProcessingException{

ProductRequest productRequest = getProductRequest() //but content method needs a string not pojo, so we can use the ObjectMapper object which will convert the POJO in to JSON, Autowire the Object Mapper

String productJson = objectMapper.writeValueAsString(productRequest);

mockMVC.perform(MockMvcRequestBuilders.post("/api/product")) 
	.contentType(MediaType.Application_JSON)
	.content(productJson)
	.andExpect(status().isCreated());

Assertions.assertEquals(1,productRepository.findAll().size());
}

okay now run the test

ProductRequest getProductRequest(){
return ProductRequest.builder().name("iPhone 13").description("iPhone 13").price(1200).build();
}


to be able to make a request from our integration test we need to use the MOCK MVC which will provide us the mocked servlet environment where we can call our controllers
Autowired the MockMVC mockMVC object, it will give error because we need to auto configure the MOCKMVC, add @AutoConfigureMockMVC at top of the class, now use object in methods

There is a playlist on JUnit5 and Mockito testing, go check it out 


EXERCISE:

Create the getProduct Test 



Now Create the ORDER Service

add dependencies -> Spring Web, Lombok, MySQL Driver, Data JPA 

now create the model package and ORDER Entity with fields -> id, orderNumber, List of OrderLineItems which as skucode, price, quantity and make relationship

create the Order Controller add @RestController, @RequestMapping("/api/order")

create a PostMethod as placeOrder(OrderRequest) which will return the String as "order placed succesffully", OrderRequest has the List of OrderLineItemsDTO 


create the test cases.

change the port because previous microservice is on 8080 by default


see now the order is placed but now we need to check the inventory is available or not, so need to create the Inventory Service

create a new service as InventoryService with dependencies -> Spring web, lombok, spring data jpa, mysql


QUESTION:
he didn't add the inventory service in parent folder where other services are, he said he is facing some issues, we will add them to one project using maven multimodules concept??????/

create the Entity Inventory with table name 't_inventory' with fields like id,skucode, quantity
create repo, controller, service

create a getmapping method as isInStock which returns true or false -> takes the skucode as path variable

when to get the value using path variable???? I can take using requestParam too right??? 

create a service and provide the implementation of isInStock method.
create method findBySkucode which will return the Optional of Inventory then use the isPresent method in service
added the @Transactional(readOnly = true)
create 2 Inventory object in mainapplication.class with CommandLineRunner Bean (Explore it). loadData method with InventoryRepository parameter.




================== CommandLineRunner Bean ================
special type of bean used to execute code after the SpringApplicationContext is fully initialized.
Typically used to run some initial logic( e.g loading data, database initialization, printing debug info).
Test or trigger some Logic at application startup.

we can define multiple CommandLineRunner Bean and also arrange them in order with @Order(1),@Order(2)


================= Clubbing the Projects =============
Create a new Maven Project -> go to file -> new project-> Maven -> next -> name ="Microservices New"
Now we are going to create 3 modules -> one for product, one for Order, and one for Inventory
Right click on project -> new -> module -> name as product-service also create for order and inventory service, delete the src folder
now we need to migrate every services under this microservices-new project
open the Product service copy all the dependencies and paste it in product-service which is in microservice-new, do same for order and inventory 
and add dependencymanagement tag in root pom of the project which is pom of microservices-new so that it could use for every services
In previous project out parent is org.springframework.boot, so in microservices-new project which we create as maven project doesn't have this parent, copy the parent from previous one and paste it in parent pom of  microservice-new.
copy the build tag and paste it in parent pom


now need to copy the sourcecode, for that delete the src folder for all services, take the src folders from previous projects and paste it
just to verify, everything is working fine, we can run a command as mvn clean verify, click the maven button on right of the intellij, click on 'm' icon and type  mvn clean verify



================== Need to learn the Liquibase ===================

================ Communication Between Services ==========================
2 types of communication
	Synchronous	Asynchronous

Order service will have the Synchronous communication with Inventory, and Async with Notification service

 ==== Inter Process Communication ===
Order Service will hit a http request to Inventory service and will get response in status of the product that the product is in stock or not, so based on this response the Order Service will either place the order successfully or will through exception or some error that the product is out of stock
so this kind of communication where the service A is waiting for the response of Service B is known as Synchronous Communication.

this kind of request(synchronous communication) are done by http clients (RestTemplate, WebClient). RestTemplate is by default in spring boot framework and we have another client as WebClient it comes from spring WebFlux project
RestTemplate is in maintanance mode, so Spring boot recommends to use the WebClient, and it also supports sync, async and streaming scenarios. 

Asynchronous is the "Fire and forget" approach 

Let's go to code where the Order service will call the Inventory service

we have created placeOrder method in Order Service so before saving the Order we need to first communicate with Inventory service and ask that is Inventory Available by calling its isAvailable method which will return boolean? then we will save or provide Exception.
configure the WebClient in order service, create a package name as config and create a java class as WebClientConfig, add the @Configuration  and define the Bean of WebClient, we cannot find the WebCient class because its part of WebFlux so we need to add its dependency, @Bean annotation create the bean with name which is the method name
now use the WebClient in order Service class use it in placeOrder method
By defaulte the client will hit the Asynchronous request, for synchronous request we have to call the block() method
Boolean isInStock = webClient.get().uri("http://localhost:8082/api/inventory/{skucode}").retrive().bodyToMono(Boolean.class).block();  
if(isInStock){
save
}else{
exception
}

but there is a problem, Inventory url is taking the skucode in path url and our order has multiple skucode, so we will not hit the http request for each skucode which is time taking and not a good practice 
we can collect all the skucode in one list and then we can provide it to inventory service api, need to modify the isInStock method of Inventory service where we take the list in path variable
/api/inventory/iphone13 -> this will be the url if there is one skucode, if more then /inventory/iphone13,iphone13-red -> this is how the path variable format looks like

and if we use the requestParam to get the skucode then it will look like: /api/inventory?sku-code = iphone13 & sku-code = iphone13-red 
we should go for request param format because it is more readable 

remove the path variable and add @RequestParam List<String> skucode and update other logic
create the Inventory Response DTO which will have the skucode and isInStock and method will return the List of InventoryResponse
now in Order service first collect all the squcode from the order and pass it

.uri("http://localhost:8082/api/inventory/{skucode}", uriBuilder -> uriBuilder.queryParam("skuCode",skuCodes).build().
and to store the response we also need to create the InventoryResponse class and get the array of them and implement the logic 




================ Spring Cloud =========
now before we were using the localhost:8082 or others to call the api, so the problem is, it works when its in our local machine, we need to deploy them on cloud and in cloud environment we cannot have a dedicated IP addresses, everything should be dynamic

we can have multiple instances of Inventory service and each instances can have a dynamic IP addresses, so in this case how our order service will know which instance to call, even if we can hardcored any instance because that instance can go down so for that we have a ServiceDiscovery pattern.
ServiceDiscovery is a concept of creating a server called as DiscoveryServer where it has all information of services that are registered like name,IP Address, Status(up,down)  

====communication with Service Discovery ========

Order service will first make a call to Discovery Server asking where I can find the Inventory service and discovery server will respond with particular IP address and then order service will make the call to the Inventory service, this is how we can avoid the hardcoded service 
when making the initial call to discovery server, discovery server will also send the registry as the response to the client , client will then store the local copy of discover server in a separate location, so if for any reason, discovery server is not available it first check the local copy, if first instance of inventory service is not available then it will check the 2nd copy   


create a new module named as discovery-server, add a dependency of Netflix Eureka(EurekaServer), this dependency has the diffenert groupid as org.springframework.cloud, so we need to add the dependency management tag (BOM dependency) copy that and paste it in root pom.xml
and need to provide the version of cloud, so add a tag in properties tag <spring-cloud.version>2021.0.2</spring-cloud.version>
create the pkg com.programming.techie.discoveryserver and create a class DiscoverServerApp and add @SpringBootAppliction, create the main method as we have create a module using maven project so that's why we need to add these things
add @EnableEurekaServer at top of the class 
create the application.properties file 
eureka.instance.hostname = localhost
eureka.client.register-with-eureka = false // don't register itself 
eureka.client.fetch-registry = false //don't fetch the registry of server in eureka server, we will make this field true in eureka client because we want client to fetch registry and store a copy of it.
server.port = 8761 //default port of eureka server 
run the project 

now need to define the eureka clients, add the eureka client dependency in every service we have created and add the annotation @EnableEurekaClient and now need to implement some configuration
eureka.client.serviceurl.defaultZone = http://localhost:8761/eureka       //property is set so that our client can find the eureka server
we can check the services on http://localhost:8761
spring.application.name = inventory-service  //change for others 	

