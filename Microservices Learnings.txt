Microservice Project

Product Service: Create and View Products, acts as Product Catalog.

Order Service: Can Order Products.

Inventory Service: Can check if product is in stock or not.

Notification Service: Can send notifications, after order is placed.

** Order Service, Inventory Service, Notification Service are going to interact with each other.

** Will have the Synchronous and Asynchronous Communication.


For Asynchronous Communication we are going to use of 2 softwares Message Queues like Kafka and Rabbit MQ's

We will use the KeyCloak as Authorization server

we will use Vault to store the secrets.

Zipkin for distributed tracing

For logging we will use Elasticsearch, logstash, Kibana.

Create the Product Service From Spring Initializer and add dependencies like spring cloud, spring web, eureka client, Lombok, mongodb

setup the mongo db in Product service and configure it in application.properties (uri, username, password, 
uri = mongodb://localhost:27817/product-service



Create a model pkg and create a Product Class there. make it Document
@Document(value = "Product")
Add All Lombok annotations

** Learn about @Builder

Product has @ID id, name, description, price

Create a repository package and create an interface as ProductRepository extends MongoRepository<Product,String>

Create a Controller package and create ProductController, annotate it with RestController, RequestMapping("/api/product")

create Api's for create, get, getAll (use @ResponseStatus for returning response)

create a ProductRequest DTO (have all fields except id because we will autogenerate it)

create service package and ProductService class to create methods related to them.

use builder method to build the Product Object

use slf4j for logging

create ProductResponse DTO for response, return everything, even id because we can use it in Order or Product identification,


Write the tests for the Product service in test package-> ProductServiceApplicationTests class
we are going the write the Integration test.

first install a library called TestContainers -> Java Library that supports the unit tests.


Learn about selenium.

add the maven dependency of TestContainers

BOM -> Bill of Materials
if we want to put the same version for all the components like for Kafka, MongoDB then use BOM dependency
take the mongodb maven dependency from TestContainers documentation
and remove the version because we have defined it in BOM dependency, otherwise it may cause issue
as we are using the JUnit 5 for testing so we need that dependency too for TestContainers and put the junit-jupiter dependency and remove the version

Let's start writing the integration test
add @TestContainers Annotation on top of the class and define the MongoDb Container inside the Test class and create its object 

MongoDbContainer is deprecated because we cannot use the NoArgsConstructor anymore, we have to manually specify the version of the MongoDbContainer, so for that we need to provide the docker image name, we are providing as "mongo:4.4.2" so this is the mongo version we want to use for test. add @Container at top of the MongoDbContainer instance and make it static .

create the static setProperties method and add annotation @DynamicPropertySource with DynamicPropertyRegistry parameter and call the add method with 2 parameters, one is uri "spring.data.mongodb.uri", mongodbcontainer::getReplicaSetUrl)
 


so at the time of starting the integration test, first test will start the mongodbcontainer with specified docker image and then it will get the replicaSetUrl and add to mongodb.uri property at time of creating the test,
we are taking the image for mongodb for testing because we dont want to use our local db




Now we are creating the test case for createProduct api in which we are expecting the ResponseStatus.Created as Response
@Test
void shouldCreateProduct() throws JsonProcessingException{

ProductRequest productRequest = getProductRequest() //but content method needs a string not pojo, so we can use the ObjectMapper object which will convert the POJO in to JSON, Autowire the Object Mapper

String productJson = objectMapper.writeValueAsString(productRequest);

mockMVC.perform(MockMvcRequestBuilders.post("/api/product")) 
	.contentType(MediaType.Application_JSON)
	.content(productJson)
	.andExpect(status().isCreated());

Assertions.assertEquals(1,productRepository.findAll().size());
}

okay now run the test

ProductRequest getProductRequest(){
return ProductRequest.builder().name("iPhone 13").description("iPhone 13").price(1200).build();
}


to be able to make a request from our integration test we need to use the MOCK MVC which will provide us the mocked servlet environment where we can call our controllers
Autowired the MockMVC mockMVC object, it will give error because we need to auto configure the MOCKMVC, add @AutoConfigureMockMVC at top of the class, now use object in methods

There is a playlist on JUnit5 and Mockito testing, go check it out 


EXERCISE:

Create the getProduct Test 



Now Create the ORDER Service

add dependencies -> Spring Web, Lombok, MySQL Driver, Data JPA 

now create the model package and ORDER Entity with fields -> id, orderNumber, List of OrderLineItems which as skucode, price, quantity and make relationship

create the Order Controller add @RestController, @RequestMapping("/api/order")

create a PostMethod as placeOrder(OrderRequest) which will return the String as "order placed succesffully", OrderRequest has the List of OrderLineItemsDTO 


create the test cases.

change the port because previous microservice is on 8080 by default


see now the order is placed but now we need to check the inventory is available or not, so need to create the Inventory Service

create a new service as InventoryService with dependencies -> Spring web, lombok, spring data jpa, mysql


QUESTION:
he didn't add the inventory service in parent folder where other services are, he said he is facing some issues, we will add them to one project using maven multimodules concept??????/

create the Entity Inventory with table name 't_inventory' with fields like id,skucode, quantity
create repo, controller, service

create a getmapping method as isInStock which returns true or false -> takes the skucode as path variable

when to get the value using path variable???? I can take using requestParam too right??? 

create a service and provide the implementation of isInStock method.
create method findBySkucode which will return the Optional of Inventory then use the isPresent method in service
added the @Transactional(readOnly = true)
create 2 Inventory object in mainapplication.class with CommandLineRunner Bean (Explore it). loadData method with InventoryRepository parameter.




================== CommandLineRunner Bean ================
special type of bean used to execute code after the SpringApplicationContext is fully initialized.
Typically used to run some initial logic( e.g loading data, database initialization, printing debug info).
Test or trigger some Logic at application startup.

we can define multiple CommandLineRunner Bean and also arrange them in order with @Order(1),@Order(2)


================= Clubbing the Projects =============
Create a new Maven Project -> go to file -> new project-> Maven -> next -> name ="Microservices New"
Now we are going to create 3 modules -> one for product, one for Order, and one for Inventory
Right click on project -> new -> module -> name as product-service also create for order and inventory service, delete the src folder
now we need to migrate every services under this microservices-new project
open the Product service copy all the dependencies and paste it in product-service which is in microservice-new, do same for order and inventory 
and add dependencymanagement tag in root pom of the project which is pom of microservices-new so that it could use for every services
In previous project out parent is org.springframework.boot, so in microservices-new project which we create as maven project doesn't have this parent, copy the parent from previous one and paste it in parent pom of  microservice-new.
copy the build tag and paste it in parent pom


now need to copy the sourcecode, for that delete the src folder for all services, take the src folders from previous projects and paste it
just to verify, everything is working fine, we can run a command as mvn clean verify, click the maven button on right of the intellij, click on 'm' icon and type  mvn clean verify



================== Need to learn the Liquibase ===================

================ Communication Between Services ==========================
2 types of communication
	Synchronous	Asynchronous

Order service will have the Synchronous communication with Inventory, and Async with Notification service

 ==== Inter Process Communication ===
Order Service will hit a http request to Inventory service and will get response in status of the product that the product is in stock or not, so based on this response the Order Service will either place the order successfully or will through exception or some error that the product is out of stock
so this kind of communication where the service A is waiting for the response of Service B is known as Synchronous Communication.

this kind of request(synchronous communication) are done by http clients (RestTemplate, WebClient). RestTemplate is by default in spring boot framework and we have another client as WebClient it comes from spring WebFlux project
RestTemplate is in maintanance mode, so Spring boot recommends to use the WebClient, and it also supports sync, async and streaming scenarios. 

Asynchronous is the "Fire and forget" approach 

Let's go to code where the Order service will call the Inventory service

we have created placeOrder method in Order Service so before saving the Order we need to first communicate with Inventory service and ask that is Inventory Available by calling its isAvailable method which will return boolean? then we will save or provide Exception.
configure the WebClient in order service, create a package name as config and create a java class as WebClientConfig, add the @Configuration  and define the Bean of WebClient, we cannot find the WebCient class because its part of WebFlux so we need to add its dependency, @Bean annotation create the bean with name which is the method name
now use the WebClient in order Service class use it in placeOrder method
By defaulte the client will hit the Asynchronous request, for synchronous request we have to call the block() method
Boolean isInStock = webClient.get().uri("http://localhost:8082/api/inventory/{skucode}").retrive().bodyToMono(Boolean.class).block();  
if(isInStock){
save
}else{
exception
}

but there is a problem, Inventory url is taking the skucode in path url and our order has multiple skucode, so we will not hit the http request for each skucode which is time taking and not a good practice 
we can collect all the skucode in one list and then we can provide it to inventory service api, need to modify the isInStock method of Inventory service where we take the list in path variable
/api/inventory/iphone13 -> this will be the url if there is one skucode, if more then /inventory/iphone13,iphone13-red -> this is how the path variable format looks like

and if we use the requestParam to get the skucode then it will look like: /api/inventory?sku-code = iphone13 & sku-code = iphone13-red 
we should go for request param format because it is more readable 

remove the path variable and add @RequestParam List<String> skucode and update other logic
create the Inventory Response DTO which will have the skucode and isInStock and method will return the List of InventoryResponse
now in Order service first collect all the squcode from the order and pass it

.uri("http://localhost:8082/api/inventory/{skucode}", uriBuilder -> uriBuilder.queryParam("skuCode",skuCodes).build().
and to store the response we also need to create the InventoryResponse class and get the array of them and implement the logic 




================ Spring Cloud =========
now before we were using the localhost:8082 or others to call the api, so the problem is, it works when its in our local machine, we need to deploy them on cloud and in cloud environment we cannot have a dedicated IP addresses, everything should be dynamic

we can have multiple instances of Inventory service and each instances can have a dynamic IP addresses, so in this case how our order service will know which instance to call, even if we can hardcored any instance because that instance can go down so for that we have a ServiceDiscovery pattern.
ServiceDiscovery is a concept of creating a server called as DiscoveryServer where it has all information of services that are registered like name,IP Address, Status(up,down)  

====communication with Service Discovery ========

Order service will first make a call to Discovery Server asking where I can find the Inventory service and discovery server will respond with particular IP address and then order service will make the call to the Inventory service, this is how we can avoid the hardcoded service 
when making the initial call to discovery server, discovery server will also send the registry as the response to the client , client will then store the local copy of discover server in a separate location, so if for any reason, discovery server is not available it first check the local copy, if first instance of inventory service is not available then it will check the 2nd copy   


create a new module named as discovery-server, add a dependency of Netflix Eureka(EurekaServer), this dependency has the diffenert groupid as org.springframework.cloud, so we need to add the dependency management tag (BOM dependency) copy that and paste it in root pom.xml
and need to provide the version of cloud, so add a tag in properties tag <spring-cloud.version>2021.0.2</spring-cloud.version>
create the pkg com.programming.techie.discoveryserver and create a class DiscoverServerApp and add @SpringBootAppliction, create the main method as we have create a module using maven project so that's why we need to add these things
add @EnableEurekaServer at top of the class 
create the application.properties file 
eureka.instance.hostname = localhost
eureka.client.register-with-eureka = false // don't register itself 
eureka.client.fetch-registry = false //don't fetch the registry of server in eureka server, we will make this field true in eureka client because we want client to fetch registry and store a copy of it.
server.port = 8761 //default port of eureka server 
run the project 

now need to define the eureka clients, add the eureka client dependency in every service we have created and add the annotation @EnableEurekaClient and now need to implement some configuration
eureka.client.serviceurl.defaultZone = http://localhost:8761/eureka       //property is set so that our client can find the eureka server
we can check the services on http://localhost:8761
spring.application.name = inventory-service  //change for others 	



====================================== Mulitple Instances of Inventory Service ==========================
Now as we saw in the theoretical examples we are going to create multiple instances of inventory service
First make the server.port = 0 // Free port (spring boot will pick a random free port and run the inventory service on that port)
select the inventory service from dropdown in IntelliJ -> edit configurations -> Allow parallel run check box, it will allow us to run the multiple instances of application.
now we can replace the hardcoded port num when using WebClient, now we can use the name of the service (inventory-service)
it will the give the error "failed to resolve 'inventory-service' after 9 queries", this is because we have multiple instances now, so client is confused which one to call, it should check the service one by one and try to call one by one, so to enable this functionality we need to configure the client side load balancing in out eureka clients.
so for that we need to add an annotation when constructing the web client bean
replace WebClient with WebClient.Builder, name of method as 'webClientBuilder' and return WebClient.Builder and add the @LoadBalanced annotation at top of the method -> this will enable the client side load balancing capabilities to the web client builder, now even though our order service finds multiple services of the inventory service it will call the services one by one
change the reference in order service class as WebClient.Builder webClientBuilder


============= Destructive Test ========
we will break some thing and will see how our system will behave like we are going to down the eureka server.
stop the discovery server
still we hit the url of order service and our order is placed successfully because we have the local copy of discovery.
now we are going to stop the both instance of inventory service and rerun the inventory serice, it will give the error as it is not able to register itself on eureka servcer because server is down (Transport Exception)
now let's see how our order service will behave, its giving the Internal Server Error, its also give the same exception 'Transport Exception' because order service will first check the local copies of inventory service which we had shut down then order service will try to contact to discovery server to fetch the registry information but its not running that's why its giving error.
now let's start the discovery server, first there is no serive register because clients take almost 30 seconds to register itself to discovery server so wait for them to register.
now hit the order api now it will successfully place the order 





================== API Gateway ================
currect model is when the user is calling the product service, it will hit the url with some random port to access the service, same for other services
This is fine for local development environment but it will not work for production environment as microservices has diffent instances and can run on different ports also, so for this reason we cannot rely on hardcoding these values to call the service
Solution is API Gateway which is responsible to route the request from users to the corresponding service  

API Gateway is like the entry point to our system, if user wants to call the Product Service, the user just call the normal Api gateway with normal url like online-shop.com, to be able to call the product service online-shop.com/api/product then in our API Gatewary we can configure the rules such that if we receive a request with url parameter as /api/product then route it to product service, if its /api/order then route this request to OrderService 

API Gateway can :
Routing based on Request Headers
Authentication  -> API Gateway can communicate with Authorization Server or Authentication Mechanism we want to implement 
Security -> we will make the API Gateway talk to our keyCloak Authorization server and will implement the security aspects
Load Balancing -> If we have multiple instances of Product Service, if user makes a call it will make sure which instance to call to retrieve the response from service and return 
SSL Termination (explore) -> usually when we are making a call to any external service to include the https scheme by following the TLS Protocol, if we call the API Gateway from outside with TLS scheme with https protocol, The API Gateway as its already part of microservice network so we don't need https within our own services which are being routed through API Gateway, we can just perform with simple http so that's why API Gateway terminate the SSL connection.
We have multiple API Gateways - APG, CONG - but we will use the Spring Clouds own implementation Spring Cloud Gateway 

Its not built on top of Spring MVC, its built on top of Spring WebFlux.

Predicates and Filters (explore)

add dependency of Gateway 
create a new maven module, add dependency in it
create package and create a class ApiGatewayApplication 
add the eureka client dependency, configure the application.properties 
eureka.client.serviceUrl.defaultzone = http://localhost:8761/eureka
application.name = api-gateway
@EnableEurekaClient

class responsible for defining the routes and identify the routes for incoming request
logging.level.org.springframework.cloud.gateway.route.RouteDefinitionLocator = INFO
logging.level.root = INFO
logging.level.org.springframework.cloud.gateway = TRACE
  
by adding these info we will have some more logs and we can understand what is going on behind the scene when the request is made on API Gateway 


*Define the Route for Product Service 
spring.cloud.gateway.routes[0].id = product-service
spring.cloud.gateway.routes[0].uri = lb://product-service       -- lb will enable the load balancing abilities
spring.cloud.gateway.routes[0].predicates[0] = Path=/api/product      ----- when we get the api call with this path then the API Gateway will route this particular request to the Product Service 

*Define routes for OrderService     
spring.cloud.gateway.routes[1].id = order-service
spring.cloud.gateway.routes[1].uri = lb://order-service
spring.cloud.gateway.routes[1].predicates[0] = Path=/api/order

Run the api gateway service on 8080 port
hit the GET api on postman http://localhost:8080/api/product  -> this request will go to API Gateway service then it will route the request to corresponding service    


*Dicover Server Route
spring.cloud.gateway.routes[2].id = discovery-server
spring.cloud.gateway.routes[2].uri = lb://localhost:8761
spring.cloud.gateway.routes[2].predicates[0] = Path=/eureka/web

this will give an error NOT FOUND because the API Gateway will call the localhot:8761/eureka/web but we need to route to localhost:8761 -- so here comes the concept of filters
we can modify the url using filters, we will remove the url parameter and change the path 

spring.cloud.gateway.routes[2].filters = SetPath=/

it will again give the error because of 'lb' in uri of route of eureka server as we have only one instance of this server

update 'lb' to 'http' 

now the request is successful but it is giving only html part of the eureka page because we have not configure the route for static files that's why its not loading the css and javascript

so for that we need to configure the route for static resources

spring.cloud.gateway.routes[3].id = discovery-server-static
spring.cloud.gateway.routes[3].uri = lb://localhost:8761
spring.cloud.gateway.routes[3].predicates[0] = Path=/eureka/**

now its fine



======================== Authorization through KeyCloak Authorization server ============
Now we need to secure our services, as now we can access any service or any endpoint without any Authorization or Authentication. 

First watch the Spring Security OAUTH2 Tutotial using KeyCloak  

so let's go through this tutorial first

=========== What is OAUTH2 ==== 

In this tutorial we are going to discuss what is OAUTH2 and how to implement OAUTH2 Features in spring boot application using spring security 

we will also discuss how to implement OAUTH2 patterns for different applications like
* Spring MVC App.
* Single Page App like Angular with Spring Boot Backend.
* M2M Authorization Between Microservices. (M2M - Machine to Machine)



What is OAUTH2? (Open Authorization)
Industry Standard Protocol, developed for authorization between services.
present version of this protocol is 2.0, hence the name OAUTH2.0

 ============ OAUTH Terminologies =========
* Resource (or) Protected Resource 
	* Anything which needs to be accessed by External Service, which needs Authorization.

* Resource Owner
	* Owner of the Protected Resource.

* Resource Server 
	* A Server which serves or hosts or stores the Protected Resource

* Client 
	* A Service or Application which is accessing the Resource through Resource Owner 

   * Public Client : Web, Mobile, Desktop, Smart TV Apps which can be accessed by public 
   * Confidential Client : Remote Shell Scripts, CRON Jobs, Microservice etc.

we have different kind of Authorization flows also called Grant Types, means for different type of client we have different ways or mechanism to get the access tokens


* Authorization Server
	* Server that generates and validates Access Tokens for Clients and permissions for user.
  Options of Authorization Server in market
	* AWS Cognito
	* Microsoft Azure AD
	* Google Identity Platform
	* OKTA 
	* KeyCloak
	* Spring Authorization Server (Early Access)

if you want to manage the authorization on your own then KeyCloak is a very good option.




============ What is OIDC ==============
* OpenID Connect 
* Protocol built on Top of OAUTH2 
* Acts as an Identity Layer. when the client wants to access resource like photos from google drive, it needs an access token from Authorization server, this access token is basically a random alpha numerical set of characaters which does not provide any info about the user which makes it hard for the client to understand and get the user info, for this reason the Identity layer will send an additional token called as Identity token which contain basic info about the user like email, firstname and last name, so when the user request the token he or she will now receive 2 tokens.
	* Access Token : Used to Verify User is Authorized to Access the Resource or not.
	* Identity Token: Used to verify the User Info and Identity of User.
OIDC is responsible for providing the Identity token.





































